/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function() {

eval("// Ensure these elements exist in your HTML\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _this = this;\nvar demosSection = document.getElementById(\"demos\");\nvar gestureRecognizer;\nvar runningMode = \"IMAGE\";\nvar enableWebcamButton;\nvar webcamRunning = false;\nvar videoHeight = \"360px\";\nvar videoWidth = \"480px\";\n// Check if Mediapipe classes are defined\nconsole.log(\"FilesetResolver:\", typeof FilesetResolver);\nconsole.log(\"GestureRecognizer:\", typeof GestureRecognizer);\nconsole.log(\"DrawingUtils:\", typeof DrawingUtils);\n// Before we can use HandLandmarker class we must wait for it to finish loading.\nvar createGestureRecognizer = function () { return __awaiter(_this, void 0, void 0, function () {\n    var vision, error_1;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                _a.trys.push([0, 3, , 4]);\n                console.log(\"Initializing gesture recognizer...\");\n                return [4 /*yield*/, FilesetResolver.forVisionTasks(\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm\")];\n            case 1:\n                vision = _a.sent();\n                return [4 /*yield*/, GestureRecognizer.createFromOptions(vision, {\n                        baseOptions: {\n                            modelAssetPath: \"https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task\",\n                            delegate: \"GPU\"\n                        },\n                        runningMode: runningMode\n                    })];\n            case 2:\n                gestureRecognizer = _a.sent();\n                demosSection.classList.remove(\"invisible\");\n                console.log(\"Gesture recognizer initialized.\");\n                return [3 /*break*/, 4];\n            case 3:\n                error_1 = _a.sent();\n                console.error(\"Failed to initialize gesture recognizer:\", error_1);\n                return [3 /*break*/, 4];\n            case 4: return [2 /*return*/];\n        }\n    });\n}); };\ncreateGestureRecognizer().then(function () {\n    console.log(\"Gesture recognizer loaded.\");\n}).catch(function (error) {\n    console.error(\"Failed to initialize gesture recognizer:\", error);\n});\nvar imageContainers = document.getElementsByClassName(\"detectOnClick\");\nfor (var i = 0; i < imageContainers.length; i++) {\n    imageContainers[i].children[0].addEventListener(\"click\", handleClick);\n}\nfunction handleClick(event) {\n    return __awaiter(this, void 0, void 0, function () {\n        var target, allCanvas, i, n, results, p, categoryName, categoryScore, handedness, canvas, canvasCtx_1, drawingUtils, _i, _a, landmarks;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!gestureRecognizer) {\n                        alert(\"Please wait for gestureRecognizer to load\");\n                        return [2 /*return*/];\n                    }\n                    if (!(runningMode === \"VIDEO\")) return [3 /*break*/, 2];\n                    runningMode = \"IMAGE\";\n                    return [4 /*yield*/, gestureRecognizer.setOptions({ runningMode: \"IMAGE\" })];\n                case 1:\n                    _b.sent();\n                    _b.label = 2;\n                case 2:\n                    target = event.target;\n                    allCanvas = target.parentNode.getElementsByClassName(\"canvas\");\n                    for (i = allCanvas.length - 1; i >= 0; i--) {\n                        n = allCanvas[i];\n                        n.parentNode.removeChild(n);\n                    }\n                    results = gestureRecognizer.recognize(target);\n                    console.log(results);\n                    if (results.gestures.length > 0) {\n                        p = target.parentNode.childNodes[3];\n                        p.setAttribute(\"class\", \"info\");\n                        categoryName = results.gestures[0][0].categoryName;\n                        categoryScore = parseFloat((results.gestures[0][0].score * 100).toFixed(2));\n                        handedness = results.handednesses[0][0].displayName;\n                        p.innerText = \"GestureRecognizer: \".concat(categoryName, \"\\n Confidence: \").concat(categoryScore, \"%\\n Handedness: \").concat(handedness);\n                        p.style.cssText = \"left: 0px; top: \".concat(target.height, \"px; width: \").concat(target.width - 10, \"px;\");\n                        canvas = document.createElement(\"canvas\");\n                        canvas.setAttribute(\"class\", \"canvas\");\n                        canvas.setAttribute(\"width\", target.naturalWidth + \"px\");\n                        canvas.setAttribute(\"height\", target.naturalHeight + \"px\");\n                        canvas.style.cssText = \"left: 0px; top: 0px; width: \".concat(target.width, \"px; height: \").concat(target.height, \"px;\");\n                        target.parentNode.appendChild(canvas);\n                        canvasCtx_1 = canvas.getContext(\"2d\");\n                        drawingUtils = new DrawingUtils(canvasCtx_1);\n                        for (_i = 0, _a = results.landmarks; _i < _a.length; _i++) {\n                            landmarks = _a[_i];\n                            drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {\n                                color: \"#00FF00\",\n                                lineWidth: 5\n                            });\n                            drawingUtils.drawLandmarks(landmarks, {\n                                color: \"#FF0000\",\n                                lineWidth: 1\n                            });\n                        }\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nvar video = document.getElementById(\"webcam\");\nvar canvasElement = document.getElementById(\"output_canvas\");\nvar canvasCtx = canvasElement.getContext(\"2d\");\nvar gestureOutput = document.getElementById(\"gesture_output\");\nfunction hasGetUserMedia() {\n    return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);\n}\nif (hasGetUserMedia()) {\n    enableWebcamButton = document.getElementById(\"webcamButton\");\n    enableWebcamButton.addEventListener(\"click\", enableCam);\n}\nelse {\n    console.warn(\"getUserMedia() is not supported by your browser\");\n}\nfunction enableCam(event) {\n    return __awaiter(this, void 0, void 0, function () {\n        var constraints;\n        return __generator(this, function (_a) {\n            if (!gestureRecognizer) {\n                alert(\"Please wait for gestureRecognizer to load\");\n                return [2 /*return*/];\n            }\n            if (webcamRunning === true) {\n                webcamRunning = false;\n                enableWebcamButton.innerText = \"ENABLE PREDICTIONS\";\n            }\n            else {\n                webcamRunning = true;\n                enableWebcamButton.innerText = \"DISABLE PREDICTIONS\";\n            }\n            constraints = {\n                video: true\n            };\n            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n                video.srcObject = stream;\n                video.addEventListener(\"loadeddata\", predictWebcam);\n            });\n            return [2 /*return*/];\n        });\n    });\n}\nvar lastVideoTime = -1;\nvar results;\nfunction predictWebcam() {\n    return __awaiter(this, void 0, void 0, function () {\n        var nowInMs, drawingUtils, _i, _a, landmarks, categoryName, categoryScore, handedness;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(runningMode === \"IMAGE\")) return [3 /*break*/, 2];\n                    runningMode = \"VIDEO\";\n                    return [4 /*yield*/, gestureRecognizer.setOptions({ runningMode: \"VIDEO\" })];\n                case 1:\n                    _b.sent();\n                    _b.label = 2;\n                case 2:\n                    nowInMs = Date.now();\n                    if (video.currentTime !== lastVideoTime) {\n                        lastVideoTime = video.currentTime;\n                        results = gestureRecognizer.recognizeForVideo(video, nowInMs);\n                    }\n                    canvasCtx.save();\n                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n                    drawingUtils = new DrawingUtils(canvasCtx);\n                    canvasElement.style.height = videoHeight;\n                    video.style.height = videoHeight;\n                    canvasElement.style.width = videoWidth;\n                    video.style.width = videoWidth;\n                    if (results.landmarks) {\n                        for (_i = 0, _a = results.landmarks; _i < _a.length; _i++) {\n                            landmarks = _a[_i];\n                            drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {\n                                color: \"#00FF00\",\n                                lineWidth: 5\n                            });\n                            drawingUtils.drawLandmarks(landmarks, {\n                                color: \"#FF0000\",\n                                lineWidth: 2\n                            });\n                        }\n                    }\n                    canvasCtx.restore();\n                    if (results.gestures.length > 0) {\n                        gestureOutput.style.display = \"block\";\n                        gestureOutput.style.width = videoWidth;\n                        categoryName = results.gestures[0][0].categoryName;\n                        categoryScore = parseFloat((results.gestures[0][0].score * 100).toFixed(2));\n                        handedness = results.handednesses[0][0].displayName;\n                        gestureOutput.innerText = \"GestureRecognizer: \".concat(categoryName, \"\\n Confidence: \").concat(categoryScore, \" %\\n Handedness: \").concat(handedness);\n                    }\n                    else {\n                        gestureOutput.style.display = \"none\";\n                    }\n                    if (webcamRunning === true) {\n                        window.requestAnimationFrame(predictWebcam);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n\n\n//# sourceURL=webpack://project5_team2/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.ts"]();
/******/ 	
/******/ })()
;